#include <Windows.h>

#include "../../lib/ACV/VFS.h"
#include "../../lib/RxHook/RxHook.h"


static size_t g_adExeBase = (size_t)GetModuleHandleW(NULL);


static uint16_t sg_aDBCSChar[2] = { 0 };
static wchar_t sg_aUnicodeChar[2] = { 0 };
static uint32_t sg_adFnGBK2UnicodeEntry = 0;
static uint32_t sg_adFnGBK2UnicodeReturn = 0;
static void __declspec(naked) GBK2Unicode()
{
	__asm
	{
		pushad;
		pushfd;
		mov bx, ax;
		shr bx, 8;
		shl ax, 8;
		or ax, bx;
		mov sg_aDBCSChar, ax;
	}

	::MultiByteToWideChar(0x3A8, NULL, (CHAR*)sg_aDBCSChar, 2, sg_aUnicodeChar, 2);

	__asm
	{
		popfd
		popad;
		mov ax, sg_aUnicodeChar;
		jmp sg_adFnGBK2UnicodeReturn;
	}
}

typedef HMODULE(WINAPI* Fn_LoadLibraryA)(LPCSTR lpLibFileName);
static Fn_LoadLibraryA sg_fnLoadLibraryA = LoadLibraryA;
HMODULE WINAPI LoadLibraryA_Hook(LPCSTR lpLibFileName)
{
	HMODULE hModule = sg_fnLoadLibraryA(lpLibFileName);

	if (!strcmp(lpLibFileName, "plugin/battle.dll"))
	{
		BYTE patch1[] = { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 };
		Rut::RxHook::SysMemWrite((void*)((DWORD)hModule + 0x238BAB), patch1, sizeof(patch1));
		Rut::RxHook::SysMemWrite((void*)((DWORD)hModule + 0x239457), patch1, sizeof(patch1));

		BYTE patch2[] = { 0xEB };
		Rut::RxHook::SysMemWrite((void*)((DWORD)hModule + 0x23B5CF), patch2, sizeof(patch2));
	}

	return hModule;
}

/*
「    SJIS 0x8175  GBK 0xA1B8
『    SJIS 0x8177  GBK 0xA1BA
（   SJIS 0x8169  GBK 0xA3A8
*/
static uint32_t sg_adBracketIS = 0;
static uint32_t sg_adBracketNO = 0;
static uint32_t sg_adBracketEntry = 0;
static void __declspec(naked) FixBracket()
{
	__asm
	{
		cmp cl, 0xA1;
		jl NO;
		cmp al, 0xB8;
		je IS;
		cmp al, 0xBA;
		je IS;
		cmp cl, 0xA3;
		jne NO;
		cmp al, 0xA8;
		je IS;

	NO:
		jmp sg_adBracketNO;
	IS:
		jmp sg_adBracketIS;
	}
}


static void PatchMenu()
{
	// × -> ×
	uint8_t aX[] = { 0xA1, 0xC1, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBF54), aX, sizeof(aX));

	// ＋ -> ＋
	uint8_t aPlus[] = { 0xA3, 0xAB, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBF50), aPlus, sizeof(aPlus));

	//画面 -> 画面
	uint8_t aPaint[] = { 0xBB, 0xAD, 0xC3, 0xE6 ,0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0E8), aPaint, sizeof(aPaint));

	//スクリーンモード  ->  显示模式
	uint8_t aScreenMode[] = { 0xCF, 0xD4, 0xCA, 0xBE, 0xC4, 0xA3, 0xCA, 0xBD, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0D4), aScreenMode, sizeof(aScreenMode));

	//ウィンドウ  ->  窗口
	uint8_t aWindow[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0C8), aWindow, sizeof(aWindow));

	//フルスクリーン  ->  全屏
	uint8_t aFullScreen[] = { 0xC8, 0xAB, 0xC6, 0xC1, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0B8), aFullScreen, sizeof(aFullScreen));

	//アスペクト比 16:9  -> 16:9
	uint8_t a16x9[] = { 0x31, 0x36, 0x3A, 0x39, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0A4), a16x9, sizeof(a16x9));

	//アスペクト比  4:3  ->  4:3
	uint8_t a4x3[] = { 0x34, 0x3A, 0x33, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC090), a4x3, sizeof(a4x3));

	//ウィンドウ位置  ->  窗口位置
	uint8_t aWindowPosition[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0xCE, 0xBB, 0xD6, 0xC3, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC06C), aWindowPosition, sizeof(aWindowPosition));

	//常に最前面で表示  ->  置顶窗口
	uint8_t aWindowTop[] = { 0xD6, 0xC3, 0xB6, 0xA5, 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC040), aWindowTop, sizeof(aWindowTop));

	//座標を保持  ->  保持位置
	uint8_t aWindowMaintain[] = { 0xB1, 0xA3, 0xB3, 0xD6, 0xCE, 0xBB, 0xD6, 0xC3, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC054), aWindowMaintain, sizeof(aWindowMaintain));

	//画面の中央  ->  屏幕居中
	uint8_t aWindowCenter[] = { 0xC6, 0xC1, 0xC4, 0xBB, 0xBE, 0xD3, 0xD6, 0xD0, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC060), aWindowCenter, sizeof(aWindowCenter));

	//ウィンドウサイズ  ->  窗口大小
	uint8_t aWindowSize[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0xB4, 0xF3, 0xD0, 0xA1, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC07C), aWindowSize, sizeof(aWindowSize));

	//フルスクリーンモード  ->  全屏模式
	uint8_t aFullScreenMode[] = { 0xC8, 0xAB, 0xC6, 0xC1, 0xC4, 0xA3, 0xCA, 0xBD, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC028), aFullScreenMode, sizeof(aFullScreenMode));

	//画面拡大縮小補間  ->  缩放算法
	uint8_t aScaling[] = { 0xCB, 0xF5, 0xB7, 0xC5, 0xCB, 0xE3, 0xB7, 0xA8, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBFE8), aScaling, sizeof(aScaling));

	//垂直同期待ち  ->  垂直同步
	uint8_t aSync[] = { 0xB4, 0xB9, 0xD6, 0xB1, 0xCD, 0xAC, 0xB2, 0xBD, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBF7C), aSync, sizeof(aSync));

	//同期無効  ->  关闭同步
	uint8_t aOffSync[] = { 0xB9, 0xD8, 0xB1, 0xD5, 0xCD, 0xAC, 0xB2, 0xBD, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBF70), aOffSync, sizeof(aOffSync));

	//サイズ固定  ->  固定大小
	uint8_t aFixSize[] = { 0xB9, 0xCC, 0xB6, 0xA8, 0xB4, 0xF3, 0xD0, 0xA1, 0x28, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBF44), aFixSize, sizeof(aFixSize));

	//等倍  ->  原始
	uint8_t aEqual[] = { 0xD4, 0xAD, 0xCA, 0xBC };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC155), aEqual, sizeof(aEqual));
}

static void PatchUIText()
{
	//起動設定  ->  启动设置
	uint8_t aBootSetup[] = { 0xC6, 0xF4, 0xB6, 0xAF, 0xC9, 0xE8, 0xD6, 0xC3, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC444), aBootSetup, sizeof(aBootSetup));

	//スクリーンモード  ->  显示模式
	uint8_t aDisplayMode[] = { 0xCF, 0xD4, 0xCA, 0xBE, 0xC4, 0xA3, 0xCA, 0xBD,0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0D4), aDisplayMode, sizeof(aDisplayMode));

	//ウィンドウ  ->  窗口
	uint8_t aWindow[] = { 0xB4, 0xB0, 0xBF, 0xDA, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0C8), aWindow, sizeof(aWindow));

	//フルスクリーン  ->  全屏
	uint8_t aFullScreen[] = { 0xC8, 0xAB, 0xC6, 0xC1,0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC0B8), aFullScreen, sizeof(aFullScreen));

	//１６：９比率  ->  16:9
	uint8_t a16x9[] = { 0x31, 0x36, 0xA3, 0xBA, 0x39, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC3DC), a16x9, sizeof(a16x9));

	//４：３比率  ->  4:3
	uint8_t a4x3[] = { 0x34, 0xA3, 0xBA, 0x33, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC3D0), a4x3, sizeof(a4x3));

	//スクリーン解像度  ->  分辨率
	uint8_t aResolution[] = { 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC3BC), aResolution, sizeof(aResolution));

	//ウィンドウサイズをスクリーン解像度に合わせる  ->  适配屏幕分辨率
	uint8_t aAdjustSize[] = { 0xCA, 0xCA, 0xC5, 0xE4, 0xC6, 0xC1, 0xC4, 0xBB, 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC384), aAdjustSize, sizeof(aAdjustSize));

	//注意事项
	uint8_t aNote[] =
	{
		0xB8, 0xDF, 0xB7, 0xD6, 0xB1, 0xE6, 0xC2, 0xCA,
		0xD0, 0xE8, 0xD2, 0xAA, 0xB8, 0xFC, 0xB8, 0xDF, 0xB5, 0xC4, 0xD3, 0xB2, 0xBC, 0xFE, 0xD0, 0xD4,
		0xC4, 0xDC, 0xD6, 0xA7, 0xB3, 0xD6,
		0x0A,
		0x44, 0x42, 0x44, 0x20, 0x28, 0x44, 0x6F, 0x74,
		0x20, 0x42, 0x79, 0x20, 0x44, 0x6F, 0x74, 0x29, 0x20, 0xBC, 0xB4, 0xB5, 0xE3, 0xB6, 0xD4, 0xB5,
		0xE3, 0xCF, 0xD4, 0xCA, 0xBE, 0x00
	};
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC2E8), aNote, sizeof(aNote));

	//存档位置1
	uint8_t aSvaePath[] =
	{
		0xCA, 0xC7, 0xB7, 0xF1, 0xC9, 0xE8, 0xD6, 0xC3, 0xCE, 0xC4, 0xB5, 0xB5, 0xCE, 0xAA, 0xB4, 0xE6,
		0xB5, 0xB5, 0xC4, 0xAC, 0xC8, 0xCF, 0xCE, 0xBB, 0xD6, 0xC3, 0xA3, 0xBF,
		0x0A,
		0xD1, 0xA1, 0xB7, 0xF1, 0xBF, 0xC9, 0xD2, 0xD4, 0xC9, 0xE8, 0xD6, 0xC3, 0xB4, 0xE6, 0xB5, 0xB5,
		0xCE, 0xBB, 0xD6, 0xC3, 0xCE, 0xAA, 0xC4, 0xBF, 0xC2, 0xBC, 0xCF, 0xC2, 0x00
	};
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBE90), aSvaePath, sizeof(aSvaePath));

	//存档位置2
	uint8_t aSvaePath2[] =
	{
		0xCA, 0xC7, 0xB7, 0xF1, 0xC9, 0xE8, 0xD6, 0xC3, 0xB4, 0xE6, 0xB5, 0xB5, 0xC2, 0xB7, 0xBE, 0xB6,
		0xCE, 0xAA, 0xD3, 0xCE, 0xCF, 0xB7, 0xC4, 0xBF, 0xC2, 0xBC, 0xCF, 0xC2, 0xA3, 0xBF, 0x00,
	};
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBE38), aSvaePath2, sizeof(aSvaePath2));

	//存档位置3
	uint8_t aSvaePath3[] = { 0xB4, 0xE6, 0xB5, 0xB5, 0xC2, 0xB7, 0xBE, 0xB6, 0xCE, 0xAA, 0x0A, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BBE64), aSvaePath3, sizeof(aSvaePath3));

	//下次启动显示设置界面
	uint8_t aNext[] =
	{
		0xCF, 0xC2, 0xB4, 0xCE, 0xC6, 0xF4, 0xB6, 0xAF, 0xCF, 0xD4, 0xCA, 0xBE, 0xC9, 0xE8, 0xD6, 0xC3,
		0xBD, 0xE7, 0xC3, 0xE6, 0x00
	};
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC2A8), aNext, sizeof(aNext));

	//詳細設定  ->  详细设置
	uint8_t aDetail[] = { 0xCF, 0xEA, 0xCF, 0xB8, 0xC9, 0xE8, 0xD6, 0xC3, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC2DC), aDetail, sizeof(aDetail));

	//起動  ->  启动
	uint8_t aBoot[] = { 0xC6, 0xF4, 0xB6, 0xAF, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC2D4), aBoot, sizeof(aBoot));

	//退出
	uint8_t aExit[] = { 0xCD, 0xCB, 0xB3, 0xF6, 0x00 };
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1BC2CC), aExit, sizeof(aExit));
}

static void PatchBattle()
{
	Rut::RxHook::DetourAttachFunc(&sg_fnLoadLibraryA, LoadLibraryA_Hook);
}

static void PatchBracket()
{
	sg_adBracketIS = g_adExeBase + 0x1EB4C;
	sg_adBracketNO = g_adExeBase + 0x1EADF;
	sg_adBracketEntry = g_adExeBase + 0x1EB3B;
	Rut::RxHook::SetHookCode_Jmp((void*)sg_adBracketEntry, FixBracket, 5);
}

static void PatchCharset()
{
	BYTE patchCharSet[] = { 0x86 }; // 0x80 - > 0x86
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x76B6F), patchCharSet, sizeof(patchCharSet));
}

static void PatchGBK2Unicode()
{
	sg_adFnGBK2UnicodeEntry = g_adExeBase + 0x570F9;
	sg_adFnGBK2UnicodeReturn = g_adExeBase + 0x57104;
	Rut::RxHook::SetHookCode_Jmp((void*)sg_adFnGBK2UnicodeEntry, GBK2Unicode, 0xB);
}

static void PatchCharacterName()
{
	BYTE patchChar1[] = { 0xA1 }; //【 8179 -> A1BE
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x255E9), patchChar1, sizeof(patchChar1));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x632CB), patchChar1, sizeof(patchChar1));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x7609E), patchChar1, sizeof(patchChar1));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x63313), patchChar1, sizeof(patchChar1));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x25612), patchChar1, sizeof(patchChar1));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x760FC), patchChar1, sizeof(patchChar1));

	BYTE patchChar2[] = { 0xBE }; //【 8179 -> A1BE
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x632E0), patchChar2, sizeof(patchChar2));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x255EF), patchChar2, sizeof(patchChar2));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x760B3), patchChar2, sizeof(patchChar2));

	BYTE patchChar3[] = { 0xBF }; //】 817A -> A1BF
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x63325), patchChar3, sizeof(patchChar3));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x25619), patchChar3, sizeof(patchChar3));
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x7610E), patchChar3, sizeof(patchChar3));
}

static void PatchGBKRangeTable()
{
	uint8_t aTable[256] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00
	};

	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1C2538), aTable, sizeof(aTable));// Code Range Table
}

static void ScriptFileRedirection()
{
	char scriptPackName[] = "script.cn";// script.dat -> script.cn
	Rut::RxHook::SysMemWrite((void*)(g_adExeBase + 0x1C1BE8), scriptPackName, sizeof(scriptPackName));
}


static void StartHook()
{
	PatchMenu();
	PatchUIText();
	PatchBattle();
	PatchBracket();
	PatchCharset();
	PatchGBK2Unicode();
	PatchGBKRangeTable();
	//PatchCharacterName(); // If no change the character name there would be no need to call this func
	//ScriptFileRedirection(); //script.dat -> scrtipt.cn

	ACV::VFS::SetHookFolder("./HanaHime_cn/");
	ACV::VFS::SetHook((uint32_t)g_adExeBase + 0xBEB30, (uint32_t)g_adExeBase + 0xCE9B0, (uint32_t)g_adExeBase + 0xB66E0);
	//ACV::VFS::SetDump((uint32_t)g_dwExeBase + 0xBEFC0, (uint32_t)g_dwExeBase + 0xCE9B0, (uint32_t)g_dwExeBase + 0xBF710, (uint32_t)g_dwExeBase + 0xB66E0);

	Rut::RxHook::HookCreateFontIndirectA(0x86, "黑体");
	Rut::RxHook::HookTitleExA("僴僫僸儊仏傾僽僜儕儏乕僩両1.30", "ハナヒメ＊アブソリュート！1.30");
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		StartHook();
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

void __declspec(dllexport) DirA() {}


